synth_values 转换为 Swift 的 struct 并起一个合适的命名

- python 原文的返回值为其成员变量
- 其函数内容为这个 struct 的 initialization 并支持 throws
- 为错误类型单独定义一个 enum 并起一个合适的命名
- 其参数类型和 python 原文中的保持一致
- 用中文在每行代码都写上注释
- 结构体和 Initialzation 按规范写名注释
- 可以使用 Accelerate 优化计算性能
- 在回复中列出所有代码不要省略
- 可以利用以下 struct:

```swift
import Accelerate

/// 计算Schmidt准归一化关联Legendre多项式及其导数的结构体
///
/// 该结构体根据给定的最大度数nmax和角度theta，预先计算并存储关联Legendre多项式值及其导数
/// 结果存储在三维数组pnm中，维度为[nmax+1, nmax+2, theta.count]
///
/// - 算法说明: 实现基于Langel的递归关系公式，支持高效计算高次多项式
/// - 性能优化: 使用Accelerate框架进行向量化计算，优化三角函数和平方根运算
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
struct SchmidtLegendrePolynomial {
    /// 存储多项式和导数的三维数组
    /// - 第一维: 阶数n (0...nmax)
    /// - 第二维: 导数标识和次数m (0...nmax+1)
    /// - 第三维: theta值的索引
    let pnm: [[[Double]]]

    /// 初始化计算Legendre多项式
    /// - Parameters:
    ///   - nmax: 最大球谐度数
    ///   - theta: 地理余纬度数组（角度制，范围0...180）
    init(nmax: Int, theta: [Double]) {
        let thetaRadians = theta.map { $0 * .pi / 180.0 } // 角度转弧度

        // 预计算cosθ和sinθ
        let cosTheta = thetaRadians.map { cos($0) }
        let sinTheta = thetaRadians.map { sin($0) }

        // 初始化三维数组（使用ContiguousArray优化内存布局）
        var pnm = [[[Double]]](repeating:
            [[Double]](repeating:
                [Double](repeating: 0.0, count: theta.count),
                count: nmax+2),
            count: nmax+1)

        // 设置初始值 P(0,0) = 1
        pnm[0][0] = [Double](repeating: 1.0, count: theta.count)

        // 计算P(1,1) = sinθ
        pnm[1][1] = sinTheta

        // 预计算平方根序列（优化递归计算）
        var rootn = [Double](repeating: 0.0, count: 2 * nmax * nmax+1)
        for i in 0..<rootn.count {
            rootn[i] = sqrt(Double(i))
        }

        // 主递归计算（优化为向量化操作）
        for m in 0..<nmax {
            // 计算P(m+1,m)项
            var pm = [Double](repeating: 0.0, count: theta.count)
            vDSP.multiply(rootn[m+m+1], pnm[m][m], result: &pm)
            vDSP.multiply(cosTheta, pm, result: &pnm[m+1][m])

            if m > 0 {
                // 计算P(m+1,m+1)项
                var pmPlus = [Double](repeating: 0.0, count: theta.count)
                vDSP.multiply(sinTheta, pm, result: &pmPlus)
                vDSP.divide(pmPlus, rootn[m+m+2], result: &pnm[m+1][m+1])
            }

            // 计算高阶项
            for n in (m+2)...nmax {
                let d = n * n - m * m
                let e = 2 * n - 1
                var term1 = [Double](repeating: 0.0, count: theta.count)
                var term2 = [Double](repeating: 0.0, count: theta.count)

                vDSP.multiply(Double(e), cosTheta, result: &term1)
                vDSP.multiply(term1, pnm[n - 1][m], result: &term1)

                vDSP.multiply(rootn[d - e], pnm[n - 2][m], result: &term2)

                var numerator = [Double](repeating: 0.0, count: theta.count)
                vDSP.subtract(term1, term2, result: &numerator)
                vDSP.divide(numerator, rootn[d], result: &pnm[n][m])
            }
        }

        // 计算导数项（优化为向量化操作）
        pnm[0][2] = pnm[1][1].map { -$0 }
        pnm[1][2] = pnm[1][0]

        for n in 2...nmax {
            // 计算dP(n,0)
            let sqrtTerm = sqrt(Double(n * n+n) / 2)
            pnm[0][n+1] = pnm[n][1].map { -sqrtTerm * $0 }

            // 计算dP(n,1)
            let term1 = pnm[n][0].map { sqrt(2 * Double(n * n+n)) * $0 }
            let term2 = pnm[n][2].map { sqrt(Double(n * n+n - 2)) * $0 }
            pnm[1][n+1] = zip(term1, term2).map { ($0 - $1) / 2 }

            // 计算高阶导数
            for m in 2..<n {
                let sqrt1 = sqrt(Double((n+m) * (n - m+1)))
                let sqrt2 = sqrt(Double((n+m+1) * (n - m)))
                pnm[m][n+1] = zip(pnm[n][m - 1], pnm[n][m+1]).map {
                    0.5 * (sqrt1 * $0 - sqrt2 * $1)
                }
            }

            // 计算dP(n,n)
            let sqrtTermN = sqrt(Double(2 * n))
            pnm[n][n+1] = pnm[n][n - 1].map { sqrtTermN * $0 / 2 }
        }

        self.pnm = pnm
    }
}
```

```swift
import Foundation

//
//  GeocentricToGeodeticConverter.swift
//

/// 地心坐标系到地理坐标系转换器（遵循 WGS-84 椭球参数）
struct GeocentricToGeodeticConverter {
    /// 地理高度（单位：千米）
    let height: Double
    /// 地理余纬度（单位：度，范围 0...180）
    let beta: Double

    /// 初始化转换器并进行地心坐标到地理坐标的完整计算
    /// - Parameters:
    ///   - radius: 地心半径（单位：千米）
    ///   - theta: 地心余纬度（单位：度，范围 0...180）
    init(radius: Double, theta: Double) {
        // WGS-84 椭球参数定义
        let eqrad = 6378.137 // 赤道半径（千米）
        let flat = 1.0 / 298.257223563 // 地球扁率
        let plrad = eqrad * (1.0 - flat) // 极半径（千米）

        // 将地心余纬度转换为弧度
        let thetaRad = theta * .pi / 180.0

        // 计算地心坐标系下的圆柱坐标分量
        let r = radius * sin(thetaRad) // 水平投影半径
        let z = radius * cos(thetaRad) // 垂直投影高度

        // 预计算平方值提升性能
        let r2 = pow(r, 2)
        let z2 = pow(z, 2)
        let a2 = pow(eqrad, 2)
        let b2 = pow(plrad, 2)

        // 计算中间变量（根据 Zhu 1994 论文公式）
        let e2 = (a2 - b2) / a2 // 第一偏心率平方
        let e4 = pow(e2, 2) // 四次方计算
        let ep2 = (a2 - b2) / b2 // 第二偏心率平方

        // 迭代计算参数（式 6a-6d）
        let F = 54 * b2 * z2
        let G = r2 + (1 - e2) * z2 - e2 * (a2 - b2)
        let c = e4 * F * r2 / pow(G, 3)
        let s = pow(1 + c + sqrt(pow(c, 2) + 2 * c), 1 / 3)

        // 计算投影参数（式 7-8）
        let P = F / (3 * pow(s + 1 / s + 1, 2) * pow(G, 2))
        let Q = sqrt(1 + 2 * e4 * P)

        // 计算中间半径（式 9）
        let r0 = -P * e2 * r / (1 + Q) + sqrt(
            0.5 * a2 * (1 + 1 / Q) -
                P * (1 - e2) * z2 / (Q * (1 + Q)) -
                0.5 * P * r2
        )

        // 计算最终参数（式 10-11）
        let U = sqrt(pow(r - e2 * r0, 2) + z2)
        let V = sqrt(pow(r - e2 * r0, 2) + (1 - e2) * z2)

        // 计算地理高度（式 12）
        let z0 = b2 * z / (a2 * V)
        let heightCalculated = U * (1 - b2 / (a2 * V))

        // 计算地理余纬度（式 13，转换为角度）
        let betaRad = atan2(z + ep2 * z0, r)
        let betaDegrees = 90 - betaRad * 180 / .pi // 转换为地理纬度

        // 属性赋值
        self.height = heightCalculated
        self.beta = betaDegrees
    }
}

```
